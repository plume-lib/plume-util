// ***** This file is automatically generated from MathPlume.java.jpp

package org.plumelib.util;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Iterator;
import java.util.List;
import java.util.NoSuchElementException;

/*>>>
import org.checkerframework.checker.index.qual.*;
import org.checkerframework.checker.lock.qual.*;
import org.checkerframework.checker.nullness.qual.*;
import org.checkerframework.common.value.qual.*;
import org.checkerframework.dataflow.qual.*;
*/

/** Mathematical utilities. */
public final class MathPlume {

  /** This class is a collection of methods; it does not represent anything. */
  private MathPlume() {
    throw new Error("do not instantiate");
  }

  ///
  /// Function versions of Java operators
  ///

  /**
   * Negates its argument.
   *
   * @param a value to negate
   * @return negative of a
   */
  /*@Pure*/
  /*@StaticallyExecutable*/
  public static int negate(int a) {
    return -a;
  }

  /**
   * Negates its argument.
   *
   * @param a value to negate
   * @return negative of a
   */
  /*@Pure*/
  /*@StaticallyExecutable*/
  public static long negate(long a) {
    return -a;
  }

  /**
   * Negates its argument.
   *
   * @param a value to negate
   * @return negative of a
   */
  /*@Pure*/
  /*@StaticallyExecutable*/
  public static double negate(double a) {
    return -a;
  }

  /**
   * Returns ~a, the bitwise complement of its argument.
   *
   * @param a value to bitwise-complement
   * @return ~a, the bitwise complement of a
   */
  /*@Pure*/
  /*@StaticallyExecutable*/
  public static int bitwiseComplement(int a) {
    return ~a;
  }

  /**
   * Returns ~a, the bitwise complement of its argument.
   *
   * @param a value to bitwise-complement
   * @return ~a, the bitwise complement of a
   */
  /*@Pure*/
  /*@StaticallyExecutable*/
  public static long bitwiseComplement(long a) {
    return ~a;
  }

  /**
   * Multiplies its arguments.
   *
   * @param x first multiplicand
   * @param y second multiplicand
   * @return x * y
   */
  /*@Pure*/
  /*@StaticallyExecutable*/
  public static int mul(int x, int y) {
    return x * y;
  }

  /**
   * Multiplies its arguments.
   *
   * @param x first multiplicand
   * @param y second multiplicand
   * @return x * y
   */
  /*@Pure*/
  /*@StaticallyExecutable*/
  public static long mul(long x, long y) {
    return x * y;
  }

  /**
   * Multiplies its arguments.
   *
   * @param x first multiplicand
   * @param y second multiplicand
   * @return x * y
   */
  /*@Pure*/
  /*@StaticallyExecutable*/
  public static double mul(double x, double y) {
    return x * y;
  }

  /**
   * Divides its arguments.
   *
   * @param x dividend
   * @param y divisor
   * @return x / y
   */
  /*@Pure*/
  /*@StaticallyExecutable*/
  public static int div(int x, int y) {
    return x / y;
  }

  /**
   * Divides its arguments.
   *
   * @param x dividend
   * @param y divisor
   * @return x / y
   */
  /*@Pure*/
  /*@StaticallyExecutable*/
  public static long div(long x, long y) {
    return x / y;
  }

  /**
   * Divides its arguments.
   *
   * @param x dividend
   * @param y divisor
   * @return x / y
   */
  /*@Pure*/
  /*@StaticallyExecutable*/
  public static double div(double x, double y) {
    return x / y;
  }

  /**
   * Returns x % y, the modulus operation applied to its arguments.
   *
   * @param x valued to be modded
   * @param y modulus
   * @return x % y
   */
  /*@Pure*/
  /*@StaticallyExecutable*/
  public static int mod(int x, int y) {
    return x % y;
  }

  /**
   * Returns x % y, the modulus operation applied to its arguments.
   *
   * @param x valued to be modded
   * @param y modulus
   * @return x % y
   */
  /*@Pure*/
  /*@StaticallyExecutable*/
  public static long mod(long x, long y) {
    return x % y;
  }

  /**
   * Returns x &lt;&lt; y, the left-shift operation applied to its arguments.
   *
   * @param x valued to be left-shifted
   * @param y magnitude of the left-shift
   * @return x &lt;&lt; y
   */
  /*@Pure*/
  /*@StaticallyExecutable*/
  public static int lshift(int x, int y) {
    return x << y;
  }

  /**
   * Returns x &lt;&lt; y, the left-shift operation applied to its arguments.
   *
   * @param x valued to be left-shifted
   * @param y magnitude of the left-shift
   * @return x &lt;&lt; y
   */
  /*@Pure*/
  /*@StaticallyExecutable*/
  public static long lshift(long x, long y) {
    return x << y;
  }

  /**
   * Returns x &gt;&gt; y, the signed right-shift operation applied to its arguments.
   *
   * @param x valued to be right-shifted
   * @param y magnitude of the right-shift
   * @return x &gt;&gt; y
   */
  /*@Pure*/
  /*@StaticallyExecutable*/
  public static int rshiftSigned(int x, int y) {
    return x >> y;
  }

  /**
   * Returns x &gt;&gt; y, the signed right-shift operation applied to its arguments.
   *
   * @param x valued to be right-shifted
   * @param y magnitude of the right-shift
   * @return x &gt;&gt; y
   */
  /*@Pure*/
  /*@StaticallyExecutable*/
  public static long rshiftSigned(long x, long y) {
    return x >> y;
  }

  /**
   * Returns x &gt;&gt;&gt; y, the unsigned right-shift operation applied to its arguments.
   *
   * @param x valued to be right-shifted
   * @param y magnitude of the right-shift
   * @return x &gt;&gt;&gt; y
   */
  /*@Pure*/
  /*@StaticallyExecutable*/
  public static int rshiftUnsigned(int x, int y) {
    return x >>> y;
  }

  /**
   * Returns x &gt;&gt;&gt; y, the unsigned right-shift operation applied to its arguments.
   *
   * @param x valued to be right-shifted
   * @param y magnitude of the right-shift
   * @return x &gt;&gt;&gt; y
   */
  /*@Pure*/
  /*@StaticallyExecutable*/
  public static long rshiftUnsigned(long x, long y) {
    return x >>> y;
  }

  /**
   * Returns x &amp; y, the bitwise and of its arguments.
   *
   * @param x first operand
   * @param y second operand
   * @return x &amp; y
   */
  /*@Pure*/
  /*@StaticallyExecutable*/
  public static int bitwiseAnd(int x, int y) {
    return x & y;
  }

  /**
   * Returns x &amp; y, the bitwise and of its arguments.
   *
   * @param x first operand
   * @param y second operand
   * @return x &amp; y
   */
  /*@Pure*/
  /*@StaticallyExecutable*/
  public static long bitwiseAnd(long x, long y) {
    return x & y;
  }

  /**
   * Returns the logical and of its arguments. The result is always 0 or 1.
   *
   * @param x first operand
   * @param y second operand
   * @return the logical and of x and y; the result is always 0 or 1
   */
  /*@Pure*/
  /*@StaticallyExecutable*/
  public static int logicalAnd(int x, int y) {
    return ((x != 0) && (y != 0)) ? 1 : 0;
  }

  /**
   * Returns the logical and of its arguments. The result is always 0 or 1.
   *
   * @param x first operand
   * @param y second operand
   * @return the logical and of x and y; the result is always 0 or 1
   */
  /*@Pure*/
  /*@StaticallyExecutable*/
  public static long logicalAnd(long x, long y) {
    return ((x != 0) && (y != 0)) ? 1 : 0;
  }

  /**
   * Returns x ^ y, the bitwise xor of its arguments.
   *
   * @param x first operand
   * @param y second operand
   * @return x ^ y
   */
  /*@Pure*/
  /*@StaticallyExecutable*/
  public static int bitwiseXor(int x, int y) {
    return x ^ y;
  }

  /**
   * Returns x ^ y, the bitwise xor of its arguments.
   *
   * @param x first operand
   * @param y second operand
   * @return x ^ y
   */
  /*@Pure*/
  /*@StaticallyExecutable*/
  public static long bitwiseXor(long x, long y) {
    return x ^ y;
  }

  /**
   * Returns the logical xor of its arguments. The result is always 0 or 1.
   *
   * @param x first operand
   * @param y second operand
   * @return the logical xor of x and y; the result is always 0 or 1
   */
  /*@Pure*/
  /*@StaticallyExecutable*/
  public static int logicalXor(int x, int y) {
    return ((x != 0) ^ (y != 0)) ? 1 : 0;
  }

  /**
   * Returns the logical xor of its arguments. The result is always 0 or 1.
   *
   * @param x first operand
   * @param y second operand
   * @return the logical xor of x and y; the result is always 0 or 1
   */
  /*@Pure*/
  /*@StaticallyExecutable*/
  public static long logicalXor(long x, long y) {
    return ((x != 0) ^ (y != 0)) ? 1 : 0;
  }

  /**
   * Returns x | y, the bitwise or of its arguments.
   *
   * @param x first operand
   * @param y second operand
   * @return x | y
   */
  /*@Pure*/
  /*@StaticallyExecutable*/
  public static int bitwiseOr(int x, int y) {
    return x | y;
  }

  /**
   * Returns x | y, the bitwise or of its arguments.
   *
   * @param x first operand
   * @param y second operand
   * @return x | y
   */
  /*@Pure*/
  /*@StaticallyExecutable*/
  public static long bitwiseOr(long x, long y) {
    return x | y;
  }

  /**
   * Returns the logical or of its arguments. The result is always 0 or 1.
   *
   * @param x first operand
   * @param y second operand
   * @return the logical or of x and y; the result is always 0 or 1
   */
  /*@Pure*/
  /*@StaticallyExecutable*/
  public static int logicalOr(int x, int y) {
    return ((x != 0) || (y != 0)) ? 1 : 0;
  }

  /**
   * Returns the logical or of its arguments. The result is always 0 or 1.
   *
   * @param x first operand
   * @param y second operand
   * @return the logical or of x and y; the result is always 0 or 1
   */
  /*@Pure*/
  /*@StaticallyExecutable*/
  public static long logicalOr(long x, long y) {
    return ((x != 0) || (y != 0)) ? 1 : 0;
  }

  ///
  /// sign
  ///

  /**
   * Returns the sign of its argument. The result is always -1, 0, or 1.
   *
   * @param a value to have its sign taken
   * @return the sign of a: -1, 0, or 1
   */
  /*@Pure*/
  /*@StaticallyExecutable*/
  public static int sign(int a) {
    if (a == 0) {
      return 0;
    } else if (a > 0) {
      return 1;
    } else {
      return -1;
    }
  }

  ///
  /// exponentiation
  ///

  /**
   * Returns of value of the first argument raised to the power of the second argument. The
   * arguments are integers.
   *
   * @param base the base
   * @param expt the exponent
   * @return base to the expt power
   * @see Math#pow(double, double)
   */
  /*@Pure*/
  /*@StaticallyExecutable*/
  public static int pow(int base, int expt) throws ArithmeticException {
    return pow_fast(base, expt);
  }

  /**
   * Returns of value of the first argument raised to the power of the second argument.
   *
   * @param base the base
   * @param expt the exponent
   * @return base to the expt power
   * @see Math#pow(double, double)
   */
  /*@Pure*/
  /*@StaticallyExecutable*/
  public static long pow(long base, long expt) throws ArithmeticException {
    return pow_fast(base, expt);
  }

  /*@Pure*/
  /*@StaticallyExecutable*/
  private static int pow_fast(int base, int expt) throws ArithmeticException {
    if (expt < 0) {
      throw new ArithmeticException("Negative exponent passed to pow");
    }

    int this_square_pow = base;
    int result = 1;
    while (expt > 0) {
      if ((expt & 1) != 0) {
        result *= this_square_pow;
      }
      expt >>= 1;
      this_square_pow *= this_square_pow;
    }
    return result;
  }

  /*@Pure*/
  /*@StaticallyExecutable*/
  private static long pow_fast(long base, long expt) throws ArithmeticException {
    if (expt < 0) {
      throw new ArithmeticException("Negative exponent passed to pow");
    }

    long this_square_pow = base;
    long result = 1;
    while (expt > 0) {
      if ((expt & 1) != 0) {
        result *= this_square_pow;
      }
      expt >>= 1;
      this_square_pow *= this_square_pow;
    }
    return result;
  }

  /*@Pure*/
  /*@StaticallyExecutable*/
  private static int pow_slow(int base, int expt) throws ArithmeticException {
    if (expt < 0) {
      throw new ArithmeticException("Negative exponent passed to pow");
    }

    int result = 1;
    for (int i = 0; i < expt; i++) {
      result *= base;
    }
    return result;
  }

  ///
  /// gcd
  ///

  /**
   * Return the greatest common divisor of the two arguments.
   *
   * @param a first operand
   * @param b second operand
   * @return greatest common divisor of a and b
   */
  /*@Pure*/
  /*@StaticallyExecutable*/
  public static int gcd(int a, int b) {

    // Euclid's method
    if (b == 0) {
      return (Math.abs(a));
    }
    a = Math.abs(a);
    b = Math.abs(b);
    while (b != 0) {
      int tmp = b;
      b = a % b;
      a = tmp;
    }
    return a;
  }

  /**
   * Return the greatest common divisor of the elements of int array a.
   *
   * @param a array of operands
   * @return greatest common divisor of the elements of a
   */
  /*@Pure*/
  /*@StaticallyExecutable*/
  public static int gcd(int[] a) {
    // Euclid's method
    if (a.length == 0) {
      return 0;
    }
    int result = a[0];
    for (int i = 1; i < a.length; i++) {
      result = gcd(a[i], result);
      if ((result == 1) || (result == 0)) {
        return result;
      }
    }
    return result;
  }

  /**
   * Return the gcd (greatest common divisor) of the differences between the elements of int array
   * a.
   *
   * @param a array of operands
   * @return greatest common divisor of the differences between the elements of a
   */
  /*@Pure*/
  /*@StaticallyExecutable*/
  public static int gcd_differences(int[] a) {
    // Euclid's method
    if (a.length < 2) {
      return 0;
    }
    int result = a[1] - a[0];
    for (int i = 2; i < a.length; i++) {
      result = gcd(a[i] - a[i - 1], result);
      if ((result == 1) || (result == 0)) {
        return result;
      }
    }
    return result;
  }

  /// gcd -- version for manipulating long (rather than int) values

  /**
   * Return the greatest common divisor of the two arguments.
   *
   * @param a first operand
   * @param b second operand
   * @return greatest common divisor of a and b
   */
  /*@Pure*/
  /*@StaticallyExecutable*/
  public static long gcd(long a, long b) {

    // Euclid's method
    if (b == 0) {
      return (Math.abs(a));
    }
    a = Math.abs(a);
    b = Math.abs(b);
    while (b != 0) {
      long tmp = b;
      b = a % b;
      a = tmp;
    }
    return a;
  }

  /**
   * Return the greatest common divisor of the elements of long array a.
   *
   * @param a array of operands
   * @return greatest common divisor of the elements of a
   */
  /*@Pure*/
  /*@StaticallyExecutable*/
  public static long gcd(long[] a) {
    // Euclid's method
    if (a.length == 0) {
      return 0;
    }
    long result = a[0];
    for (int i = 1; i < a.length; i++) {
      result = gcd(a[i], result);
      if ((result == 1) || (result == 0)) {
        return result;
      }
    }
    return result;
  }

  /**
   * Return the gcd (greatest common divisor) of the differences between the elements of long array
   * a.
   *
   * @param a array of operands
   * @return greatest common divisor of the differences between the elements of a
   */
  /*@Pure*/
  /*@StaticallyExecutable*/
  public static long gcd_differences(long[] a) {
    // Euclid's method
    if (a.length < 2) {
      return 0;
    }
    long result = a[1] - a[0];
    for (int i = 2; i < a.length; i++) {
      result = gcd(a[i] - a[i - 1], result);
      if ((result == 1) || (result == 0)) {
        return result;
      }
    }
    return result;
  }

  /**
   * Return the greatest common divisor of the two arguments.
   *
   * @param a first operand
   * @param b second operand
   * @return greatest common divisor of a and b
   */
  /*@Pure*/
  /*@StaticallyExecutable*/
  public static double gcd(double a, double b) {

    if (a == Double.POSITIVE_INFINITY
        || a == Double.NEGATIVE_INFINITY
        || Double.isNaN(a)
        || b == Double.POSITIVE_INFINITY
        || b == Double.NEGATIVE_INFINITY
        || Double.isNaN(b)) {
      return Double.NaN;
    }

    // Euclid's method
    if (b == 0) {
      return (Math.abs(a));
    }
    a = Math.abs(a);
    b = Math.abs(b);
    while (b != 0) {
      double tmp = b;
      b = a % b;
      a = tmp;
    }
    return a;
  }

  /**
   * Return the greatest common divisor of the elements of double array a.
   *
   * @param a array of operands
   * @return greatest common divisor of the elements of a
   */
  /*@Pure*/
  /*@StaticallyExecutable*/
  public static double gcd(double[] a) {
    // Euclid's method
    if (a.length == 0) {
      return 0;
    }
    double result = a[0];
    for (int i = 1; i < a.length; i++) {
      result = gcd(a[i], result);
      if ((result == 1) || (result == 0)) {
        return result;
      }
    }
    return result;
  }

  /**
   * Return the gcd (greatest common divisor) of the differences between the elements of double
   * array a.
   *
   * @param a array of operands
   * @return greatest common divisor of the differences between the elements of a
   */
  /*@Pure*/
  /*@StaticallyExecutable*/
  public static double gcd_differences(double[] a) {
    // Euclid's method
    if (a.length < 2) {
      return 0;
    }
    double result = a[1] - a[0];
    for (int i = 2; i < a.length; i++) {
      result = gcd(a[i] - a[i - 1], result);
      if ((result == 1) || (result == 0)) {
        return result;
      }
    }
    return result;
  }

  ///
  /// Modulus
  ///

  /**
   * Return z such that {@code (z == x mod y) && (0 <= z < abs(y))}. This should really be named
   * {@code mod_nonnegative} rather than {@code mod_positive}.
   *
   * @param x value to be modded
   * @param y modulus
   * @return x % y, where the result is constrained to be non-negative
   */
  @SuppressWarnings(
      "index") // result is non-negative because either y is positive (-> x % y is non-negative) or |y| is added to x % y, which is also non-negative
  /*@Pure*/
  /*@StaticallyExecutable*/
  public static /*@NonNegative*/ /*@LessThan("#2")*/ /*@PolyUpperBound*/ int mod_positive(
      int x, /*@PolyUpperBound*/ int y) {
    int result = x % y;
    if (result < 0) {
      result += Math.abs(y);
    }
    return result;
  }

  /**
   * Return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m). The
   * largest possible modulus is used, and the trivial constraint that all integers are equal to 0
   * mod 1 is not returned (null is returned instead). Also, return null if the array is less than 3
   * elements long.
   *
   * @param nums array of operands
   * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m), or
   *     null if no such exists or the iterator contains fewer than 3 elements
   */
  /*@Pure*/
  /*@StaticallyExecutable*/
  public static int /*@Nullable*/ /*@ArrayLen(2)*/[] modulus(int[] nums) {
    if (nums.length < 3) {
      return null;
    }

    int modulus = Math.abs(gcd_differences(nums));
    if ((modulus == 0) || (modulus == 1)) {
      return null;
    }

    int remainder = nums[0] % modulus;
    if (remainder < 0) {
      remainder += modulus;
    }

    return new int[] {remainder, modulus};
  }

  /**
   * The iterator produces Integer values. This can be more efficient than modulus(int[]) if the
   * int[] doesn't already exist, because this does not necessarily examine every value produced by
   * its iterator.
   *
   * @param itor iterator of operands
   * @return an array of two integers (r,m) such that each number in itor is equal to r (mod m), or
   *     null if no such exists or the iterator contains fewer than 3 elements
   * @see #modulus(int[])
   */
  public static int /*@Nullable*/ /*@ArrayLen(2)*/[] modulus_int(Iterator<Integer> itor) {
    if (!itor.hasNext()) {
      return null;
    }
    int avalue = itor.next().intValue();
    if (!itor.hasNext()) {
      return null;
    }
    int modulus = Math.abs(avalue - itor.next().intValue());
    if (modulus == 1) {
      return null;
    }
    int count = 2;
    while (itor.hasNext()) {
      int i = itor.next().intValue();
      if (i == avalue) {
        continue;
      }
      modulus = MathPlume.gcd(modulus, Math.abs(avalue - i));
      count++;
      if (modulus == 1) {
        return null;
      }
    }
    if (count < 3) {
      return null;
    }
    return new int[] {MathPlume.mod_positive(avalue, modulus), modulus};
  }

  /**
   * Return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m). The
   * largest possible modulus is used, and the trivial constraint that all integers are equal to 0
   * mod 1 is not returned (null is returned instead).
   *
   * <p>This "_strict" version requires its input to be sorted, and no element may be missing.
   *
   * <p>This "_strict" version differs from the regular modulus by requiring that the argument be
   * dense: that is, every pair of numbers in the argument array is separated by exactly the
   * modulus.
   *
   * <p>The endpoints can be treated in two different ways: Either exactly like other numbers in the
   * input, or they can merely be checked for the condition without the strict density requirement.
   *
   * @param nums array of operands
   * @param nonstrict_ends whether endpoints are NOT subject to the strict density requirement
   * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m), or
   *     null if no such exists or the array contains fewer than 3 elements
   */
  /*@Pure*/
  /*@StaticallyExecutable*/
  public static int /*@Nullable*/ /*@ArrayLen(2)*/[] modulus_strict(
      int[] nums, boolean nonstrict_ends) {
    if (nums.length < 3) {
      return null;
    }

    int first_index = 0;
    int last_index = nums.length - 1;
    int first_nonstrict = 0; // arbitrary initial value
    int last_nonstrict = 0; // arbitrary initial value
    if (nonstrict_ends) {
      first_nonstrict = nums[first_index];
      first_index++;
      last_nonstrict = nums[last_index];
      last_index--;
    }
    if (last_index - first_index < 2) {
      return null;
    }

    int modulus = nums[first_index + 1] - nums[first_index];
    if (modulus == 1) {
      return null;
    }
    for (int i = first_index + 2; i <= last_index; i++) {
      if (nums[i] - nums[i - 1] != modulus) {
        return null;
      }
    }

    int r = mod_positive(nums[first_index], modulus);
    if (nonstrict_ends) {
      if ((r != mod_positive(first_nonstrict, modulus))
          || (r != mod_positive(last_nonstrict, modulus))) {
        return null;
      }
    }

    return new int[] {r, modulus};
  }

  /**
   * The iterator produces Integer values. This can be more efficient than modulus(int[]) if the
   * int[] doesn't already exist, because this does not necessarily examine every value produced by
   * its iterator.
   *
   * <p>For documentation, see {@link #modulus_strict(int[], boolean)}.
   *
   * @param itor iterator of operands
   * @param nonstrict_ends whether endpoints are NOT subject to the strict density requirement
   * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m), or
   *     null if no such exists or the iterator contains fewer than 3 elements
   * @see #modulus_strict(int[], boolean)
   */
  public static int /*@Nullable*/ /*@ArrayLen(2)*/[] modulus_strict_int(
      Iterator<Integer> itor, boolean nonstrict_ends) {
    if (!itor.hasNext()) {
      return null;
    }

    int first_nonstrict = 0; // arbitrary initial value
    int last_nonstrict = 0; // arbitrary initial value
    if (nonstrict_ends) {
      first_nonstrict = itor.next().intValue();
    }

    int prev = itor.next().intValue();
    if (!itor.hasNext()) {
      return null;
    }
    int next = itor.next().intValue();
    int modulus = next - prev;
    if (modulus == 1) {
      return null;
    }
    int count = 2;
    while (itor.hasNext()) {
      prev = next;
      next = itor.next().intValue();
      if (nonstrict_ends && (!itor.hasNext())) {
        last_nonstrict = next;
        break;
      }

      if (next - prev != modulus) {
        return null;
      }
      count++;
    }
    if (count < 3) {
      return null;
    }

    int r = MathPlume.mod_positive(next, modulus);
    if (nonstrict_ends) {
      if ((r != mod_positive(first_nonstrict, modulus))
          || (r != mod_positive(last_nonstrict, modulus))) {
        return null;
      }
    }

    return new int[] {r, modulus};
  }

  /// modulus for long (as opposed to int) values

  /**
   * Return z such that {@code (z == x mod y) && (0 <= z < abs(y))}. This should really be named
   * {@code mod_nonnegative} rather than {@code mod_positive}.
   *
   * @param x value to be modded
   * @param y modulus
   * @return x % y, where the result is constrained to be non-negative
   */
  @SuppressWarnings(
      "index") // result is non-negative because either y is positive (-> x % y is non-negative) or |y| is added to x % y, which is also non-negative
  /*@Pure*/
  /*@StaticallyExecutable*/
  public static /*@NonNegative*/ /*@LessThan("#2")*/ /*@PolyUpperBound*/ long mod_positive(
      long x, /*@PolyUpperBound*/ long y) {
    long result = x % y;
    if (result < 0) {
      result += Math.abs(y);
    }
    return result;
  }

  /**
   * Return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m). The
   * largest possible modulus is used, and the trivial constraint that all integers are equal to 0
   * mod 1 is not returned (null is returned instead). Also, return null if the array is less than 3
   * elements long.
   *
   * @param nums array of operands
   * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m), or
   *     null if no such exists or the iterator contains fewer than 3 elements
   */
  /*@Pure*/
  /*@StaticallyExecutable*/
  public static long /*@Nullable*/ /*@ArrayLen(2)*/[] modulus(long[] nums) {
    if (nums.length < 3) {
      return null;
    }

    long modulus = Math.abs(gcd_differences(nums));
    if ((modulus == 0) || (modulus == 1)) {
      return null;
    }

    long remainder = nums[0] % modulus;
    if (remainder < 0) {
      remainder += modulus;
    }

    return new long[] {remainder, modulus};
  }

  /**
   * The iterator produces Long values. This can be more efficient than modulus(long[]) if the
   * long[] doesn't already exist, because this does not necessarily examine every value produced by
   * its iterator.
   *
   * @param itor iterator of operands
   * @return an array of two integers (r,m) such that each number in itor is equal to r (mod m), or
   *     null if no such exists or the iterator contains fewer than 3 elements
   * @see #modulus(long[])
   */
  public static long /*@Nullable*/ /*@ArrayLen(2)*/[] modulus_long(Iterator<Long> itor) {
    if (!itor.hasNext()) {
      return null;
    }
    long avalue = itor.next().longValue();
    if (!itor.hasNext()) {
      return null;
    }
    long modulus = Math.abs(avalue - itor.next().longValue());
    if (modulus == 1) {
      return null;
    }
    int count = 2;
    while (itor.hasNext()) {
      long i = itor.next().longValue();
      if (i == avalue) {
        continue;
      }
      modulus = MathPlume.gcd(modulus, Math.abs(avalue - i));
      count++;
      if (modulus == 1) {
        return null;
      }
    }
    if (count < 3) {
      return null;
    }
    return new long[] {MathPlume.mod_positive(avalue, modulus), modulus};
  }

  /**
   * Return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m). The
   * largest possible modulus is used, and the trivial constraint that all integers are equal to 0
   * mod 1 is not returned (null is returned instead).
   *
   * <p>This "_strict" version requires its input to be sorted, and no element may be missing.
   *
   * <p>This "_strict" version differs from the regular modulus by requiring that the argument be
   * dense: that is, every pair of numbers in the argument array is separated by exactly the
   * modulus.
   *
   * <p>The endpoints can be treated in two different ways: Either exactly like other numbers in the
   * input, or they can merely be checked for the condition without the strict density requirement.
   *
   * @param nums array of operands
   * @param nonstrict_ends whether endpoints are NOT subject to the strict density requirement
   * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m), or
   *     null if no such exists or the array contains fewer than 3 elements
   */
  /*@Pure*/
  /*@StaticallyExecutable*/
  public static long /*@Nullable*/ /*@ArrayLen(2)*/[] modulus_strict(
      long[] nums, boolean nonstrict_ends) {
    if (nums.length < 3) {
      return null;
    }

    int first_index = 0;
    int last_index = nums.length - 1;
    long first_nonstrict = 0; // arbitrary initial value
    long last_nonstrict = 0; // arbitrary initial value
    if (nonstrict_ends) {
      first_nonstrict = nums[first_index];
      first_index++;
      last_nonstrict = nums[last_index];
      last_index--;
    }
    if (last_index - first_index < 2) {
      return null;
    }

    long modulus = nums[first_index + 1] - nums[first_index];
    if (modulus == 1) {
      return null;
    }
    for (int i = first_index + 2; i <= last_index; i++) {
      if (nums[i] - nums[i - 1] != modulus) {
        return null;
      }
    }

    long r = mod_positive(nums[first_index], modulus);
    if (nonstrict_ends) {
      if ((r != mod_positive(first_nonstrict, modulus))
          || (r != mod_positive(last_nonstrict, modulus))) {
        return null;
      }
    }

    return new long[] {r, modulus};
  }

  /**
   * The iterator produces Long values. This can be more efficient than modulus(long[]) if the
   * long[] doesn't already exist, because this does not necessarily examine every value produced by
   * its iterator.
   *
   * <p>For documentation, see {@link #modulus_strict(long[], boolean)}.
   *
   * @param itor iterator of operands
   * @param nonstrict_ends whether endpoints are NOT subject to the strict density requirement
   * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m), or
   *     null if no such exists or the iterator contains fewer than 3 elements
   * @see #modulus_strict(int[], boolean)
   */
  public static long /*@Nullable*/ /*@ArrayLen(2)*/[] modulus_strict_long(
      Iterator<Long> itor, boolean nonstrict_ends) {
    if (!itor.hasNext()) {
      return null;
    }

    long first_nonstrict = 0; // arbitrary initial value
    long last_nonstrict = 0; // arbitrary initial value
    if (nonstrict_ends) {
      first_nonstrict = itor.next().longValue();
    }

    long prev = itor.next().longValue();
    if (!itor.hasNext()) {
      return null;
    }
    long next = itor.next().longValue();
    long modulus = next - prev;
    if (modulus == 1) {
      return null;
    }
    int count = 2;
    while (itor.hasNext()) {
      prev = next;
      next = itor.next().longValue();
      if (nonstrict_ends && (!itor.hasNext())) {
        last_nonstrict = next;
        break;
      }

      if (next - prev != modulus) {
        return null;
      }
      count++;
    }
    if (count < 3) {
      return null;
    }

    long r = MathPlume.mod_positive(next, modulus);
    if (nonstrict_ends) {
      if ((r != mod_positive(first_nonstrict, modulus))
          || (r != mod_positive(last_nonstrict, modulus))) {
        return null;
      }
    }

    return new long[] {r, modulus};
  }

  ///
  /// Non-Modulus
  ///

  /**
   * Return an array containing all the numbers <b>not</b> in its argument array (which must be
   * non-empty) but in the argument's range; that is, bigger than its argument's minimum value and
   * smaller than its argument's maximum value. The result contains no duplicates and is in order.
   *
   * @param nums numbers to be excluded; length &gt; 0; may contain duplicates
   * @return the set: [min(nums)..max(nums)] - nums
   */
  @SuppressWarnings({"purity", "lock"})
  /*@Pure*/
  /*@StaticallyExecutable*/
  public static int[] missing_numbers(int /*@MinLen(1)*/[] nums) {
    // avoid modifying parameter
    nums = nums.clone();
    Arrays.sort(nums);
    int min = nums[0];
    int max = nums[nums.length - 1];
    int sizeEstimate = max - min + 1 - nums.length;
    List<Integer> resultList = new ArrayList<Integer>(sizeEstimate < 1 ? 1 : sizeEstimate);
    int val = min;
    for (int i = 0; i < nums.length; i++) {
      while (val < nums[i]) {
        resultList.add(val);
        val++;
      }
      if (val == nums[i]) {
        val++;
      }
    }
    int[] resultArray = new int[resultList.size()];
    for (int i = 0; i < resultArray.length; i++) {
      resultArray[i] = resultList.get(i).intValue();
    }
    return resultArray;
  }

  /**
   * This iterator returns all the numbers *not* in its argument array (which must be non-empty) but
   * in the argument's range; that is, bigger than its argument's minimum value and smaller than its
   * argument's maximum value. The result contains no duplicates and is in order. If boolean
   * add_ends is set, then the bracketing endpoints are also returned; otherwise, all returned
   * values are between the minimum and maximum of the original values.
   */
  static final class MissingNumbersIteratorInt implements Iterator<Integer> {
    // Exactly one of nums and nums_itor is non-null.
    int /*@MonotonicNonNull*/ /*@MinLen(1)*/[] nums;
    /*@MonotonicNonNull*/ Iterator<Integer> nums_itor;
    int current_nonmissing;
    int current_missing;
    // Used only if nums != null, in which case it is an index into nums.
    /*@IndexFor("nums")*/ int current_index;
    boolean add_ends;

    /**
     * An iterator over all the numbers <b>not</b> in its original argument array, but within its
     * range.
     *
     * @param nums a non-empty array
     * @param add_ends if true, include the bracketing endpoints
     */
    MissingNumbersIteratorInt(int /*@MinLen(1)*/[] nums, boolean add_ends) {
      this.add_ends = add_ends;
      { // avoid modifying parameter
        int[] nums_copy = new int[nums.length];
        System.arraycopy(nums, 0, nums_copy, 0, nums.length);
        nums = nums_copy;
      }
      Arrays.sort(nums);
      this.nums = nums;
      current_index = 0;
      current_nonmissing = nums[current_index];
      if (add_ends) {
        current_missing = current_nonmissing - 1;
      } else {
        current_missing = current_nonmissing;
      }
    }

    // The argument iterator must return the Integers in sorted order
    MissingNumbersIteratorInt(Iterator<Integer> nums_itor, boolean add_ends) {
      this.add_ends = add_ends;
      if (!nums_itor.hasNext()) {
        throw new Error("No elements in nums_itor");
      }
      current_nonmissing = nums_itor.next().intValue();
      if (add_ends) {
        current_missing = current_nonmissing - 1;
      } else {
        current_missing = current_nonmissing;
      }
      this.nums_itor = nums_itor;
      @SuppressWarnings("index") // unused variable, so value doesn't matter
      /*@IndexFor("nums")*/ int unused = Integer.MIN_VALUE;
      current_index = unused;
    }

    @Override
    public boolean hasNext(/*>>>@GuardSatisfied MissingNumbersIteratorInt this*/) {
      if (current_missing < current_nonmissing) {
        return true;
      }
      // This loop ("while" instead of "if") permits duplicates in nums.
      while (current_missing == current_nonmissing) {
        if (nums != null) {
          @SuppressWarnings(
              "index") // This breaks the invariant, but it's checked right below and the function exits.
          /*@IndexFor("nums")*/ int current_index_temp = current_index + 1;
          current_index = current_index_temp;
          if (current_index >= nums.length) {
            if (add_ends) {
              current_missing++;
              return true;
            } else {
              return false;
            }
          }
          current_nonmissing = nums[current_index];
        } else if (nums_itor != null) {
          if (!nums_itor.hasNext()) {
            if (add_ends) {
              current_missing++;
              return true;
            } else {
              return false;
            }
          }
          // prev_nonmissing is for testing only
          int prev_nonmissing = current_nonmissing;
          current_nonmissing = nums_itor.next().intValue();
          if (!(prev_nonmissing < current_nonmissing)) {
            throw new Error(
                "Non-sorted Iterator supplied to MissingNumbersIteratorInt: prev_nonmissing = "
                    + prev_nonmissing
                    + ", current_nonmissing = "
                    + current_nonmissing);
          }
        } else {
          throw new Error("Can't happen");
        }
        current_missing++;
        return hasNext();
      }
      if (add_ends) {
        return (current_missing == current_nonmissing + 1);
      } else {
        throw new Error("Can't happen: " + current_missing + " " + current_nonmissing);
      }
    }

    @Override
    public Integer next(/*>>>@GuardSatisfied MissingNumbersIteratorInt this*/) {
      if (!hasNext()) {
        throw new NoSuchElementException();
      }
      Integer result = current_missing;
      current_missing++;
      return result;
    }

    @Override
    public void remove(/*>>>@GuardSatisfied MissingNumbersIteratorInt this*/) {
      throw new UnsupportedOperationException();
    }
  }

  /**
   * Return a tuple of (r,m) where no number in NUMS is equal to r (mod m) but all missing numbers
   * in their range are. Returns null if the input array has 0 length.
   *
   * @param nums the list of operands
   * @return a (remainder, modulus) pair that fails to match elements of nums
   */
  @SuppressWarnings({"purity", "lock"})
  /*@Pure*/
  /*@StaticallyExecutable*/
  public static int /*@Nullable*/ /*@ArrayLen(2)*/[] nonmodulus_strict(int[] nums) {
    // This implementation is particularly inefficient; find a better way to
    // compute this.  Perhaps obtain the new modulus numbers incrementally
    // instead of all at once.
    if (nums.length == 0) {
      return null;
    }
    int range = ArraysPlume.element_range(nums);
    if (range > 65536) {
      return null;
    }
    return nonmodulus_strict_int_internal(new MissingNumbersIteratorInt(nums, true));
  }

  private static int /*@Nullable*/ /*@ArrayLen(2)*/[] nonmodulus_strict_int_internal(
      Iterator<Integer> missing) {
    // Must not use regular modulus:  that can produce errors, eg
    // nonmodulus_strict({1,2,3,5,6,7,9,11}) => {0,2}.  Thus, use
    // modulus_strict.
    CollectionsPlume.RemoveFirstAndLastIterator<Integer> missing_nums =
        new CollectionsPlume.RemoveFirstAndLastIterator<Integer>(missing);
    int[] result = modulus_strict_int(missing_nums, false);
    if (result == null) {
      return result;
    }
    if (!check_first_and_last_nonmodulus(result, missing_nums)) {
      return null;
    }

    return result;
  }

  /** The first argument is an array containing two elements. */
  private static boolean check_first_and_last_nonmodulus(
      int /*@ArrayLen(2)*/[] rm, CollectionsPlume.RemoveFirstAndLastIterator<Integer> rfali) {
    int r = rm[0];
    int m = rm[1];
    int first = rfali.getFirst().intValue();
    int last = rfali.getLast().intValue();
    return ((r != mod_positive(first, m)) && (r != mod_positive(last, m)));
  }

  /**
   * Return a tuple of (r,m) where no number in NUMS is equal to r (mod m) but all missing numbers
   * in their range are.
   *
   * @param nums the list of operands
   * @return a (remainder, modulus) pair that fails to match elements of nums
   */
  public static int /*@Nullable*/ /*@ArrayLen(2)*/[] nonmodulus_strict_int(Iterator<Integer> nums) {
    return nonmodulus_strict_int_internal(new MissingNumbersIteratorInt(nums, true));
  }

  // Old, slightly less efficient implementation that uses the version of
  // missing_numbers that returns an array instead of an Iterator.
  // /**
  //  * Return a tuple of (r,m) where no number in NUMS is equal to r (mod
  //  * m) but all missing numbers in their range are.
  //  */
  // public static int /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict(int[] nums) {
  //   // This implementation is particularly inefficient; find a better way to
  //   // compute this.  Perhaps obtain the new modulus numbers incrementally
  //   // instead of all at once.
  //   if (nums.length == 0) {
  //     return null;
  //   }
  //   int range = ArraysPlume.element_range(nums);
  //   if (range > 65536) {
  //     return null;
  //   }
  //   return modulus(missing_numbers(nums));
  // }

  /**
   * Return a tuple of (r,m) where no number in NUMS is equal to r (mod m) but for every number in
   * NUMS, at least one is equal to every non-r remainder. The modulus is chosen as small as
   * possible, but no greater than half the range of the input numbers (else null is returned).
   *
   * @param nums the list of operands
   * @return a (remainder, modulus) pair that fails to match elements of nums
   */
  // This seems to give too many false positives (or maybe my probability
  // model was wrong); use nonmodulus_strict instead.
  @SuppressWarnings("purity")
  /*@Pure*/
  /*@StaticallyExecutable*/
  public static int /*@Nullable*/ /*@ArrayLen(2)*/[] nonmodulus_nonstrict(int[] nums) {
    if (nums.length < 4) {
      return null;
    }
    int max_modulus = Math.min(nums.length / 2, ArraysPlume.element_range(nums) / 2);

    // System.out.println("nums.length=" + nums.length + ", range=" + ArraysPlume.element_range(nums) + ", max_modulus=" + max_modulus);

    // no real sense checking 2, as common_modulus would have found it, but
    // include it to make this function stand on its own
    for (int m = 2; m <= max_modulus; m++) {
      // System.out.println("Trying m=" + m);
      boolean[] has_modulus = new boolean[m]; // initialized to false?
      int num_nonmodulus = m;
      for (int i = 0; i < nums.length; i++) {
        /*@IndexFor("has_modulus")*/ int rem = mod_positive(nums[i], m);
        if (!has_modulus[rem]) {
          has_modulus[rem] = true;
          num_nonmodulus--;
          // System.out.println("rem=" + rem + " for " + nums[i] + "; num_nonmodulus=" + num_nonmodulus);
          if (num_nonmodulus == 0) {
            // Quit as soon as we see every remainder instead of processing
            // each element of the input list.
            break;
          }
        }
      }
      // System.out.println("For m=" + m + ", num_nonmodulus=" + num_nonmodulus);
      if (num_nonmodulus == 1) {
        return new int[] {ArraysPlume.indexOf(has_modulus, false), m};
      }
    }
    return null;
  }

  /// non-modulus for long (as opposed to int) values

  /**
   * Return an array containing all the numbers <b>not</b> in its argument array (which must be
   * non-empty) but in the argument's range; that is, bigger than its argument's minimum value and
   * smaller than its argument's maximum value. The result contains no duplicates and is in order.
   *
   * @param nums numbers to be excluded; length &gt; 0; may contain duplicates
   * @return the set: [min(nums)..max(nums)] - nums
   */
  @SuppressWarnings({"purity", "lock"})
  /*@Pure*/
  /*@StaticallyExecutable*/
  public static long[] missing_numbers(long /*@MinLen(1)*/[] nums) {
    // avoid modifying parameter
    nums = nums.clone();
    Arrays.sort(nums);
    long min = nums[0];
    long max = nums[nums.length - 1];
    int sizeEstimate = ((int) (max - min + 1 - nums.length));
    List<Long> resultList = new ArrayList<Long>(sizeEstimate < 1 ? 1 : sizeEstimate);
    long val = min;
    for (int i = 0; i < nums.length; i++) {
      while (val < nums[i]) {
        resultList.add(val);
        val++;
      }
      if (val == nums[i]) {
        val++;
      }
    }
    long[] resultArray = new long[resultList.size()];
    for (int i = 0; i < resultArray.length; i++) {
      resultArray[i] = resultList.get(i).longValue();
    }
    return resultArray;
  }

  /**
   * This iterator returns all the numbers *not* in its argument array (which must be non-empty) but
   * in the argument's range; that is, bigger than its argument's minimum value and smaller than its
   * argument's maximum value. The result contains no duplicates and is in order. If boolean
   * add_ends is set, then the bracketing endpoints are also returned; otherwise, all returned
   * values are between the minimum and maximum of the original values.
   */
  static final class MissingNumbersIteratorLong implements Iterator<Long> {
    // Exactly one of nums and nums_itor is non-null.
    long /*@MonotonicNonNull*/ /*@MinLen(1)*/[] nums;
    /*@MonotonicNonNull*/ Iterator<Long> nums_itor;
    long current_nonmissing;
    long current_missing;
    // Used only if nums != null, in which case it is an index into nums.
    /*@IndexFor("nums")*/ int current_index;
    boolean add_ends;

    /**
     * An iterator over all the numbers <b>not</b> in its original argument array, but within its
     * range.
     *
     * @param nums a non-empty array
     * @param add_ends if true, include the bracketing endpoints
     */
    MissingNumbersIteratorLong(long /*@MinLen(1)*/[] nums, boolean add_ends) {
      this.add_ends = add_ends;
      { // avoid modifying parameter
        long[] nums_copy = new long[nums.length];
        System.arraycopy(nums, 0, nums_copy, 0, nums.length);
        nums = nums_copy;
      }
      Arrays.sort(nums);
      this.nums = nums;
      current_index = 0;
      current_nonmissing = nums[current_index];
      if (add_ends) {
        current_missing = current_nonmissing - 1;
      } else {
        current_missing = current_nonmissing;
      }
    }

    // The argument iterator must return the Integers in sorted order
    MissingNumbersIteratorLong(Iterator<Long> nums_itor, boolean add_ends) {
      this.add_ends = add_ends;
      if (!nums_itor.hasNext()) {
        throw new Error("No elements in nums_itor");
      }
      current_nonmissing = nums_itor.next().longValue();
      if (add_ends) {
        current_missing = current_nonmissing - 1;
      } else {
        current_missing = current_nonmissing;
      }
      this.nums_itor = nums_itor;
      @SuppressWarnings("index") // unused variable, so value doesn't matter
      /*@IndexFor("nums")*/ int unused = Integer.MIN_VALUE;
      current_index = unused;
    }

    @Override
    public boolean hasNext(/*>>>@GuardSatisfied MissingNumbersIteratorLong this*/) {
      if (current_missing < current_nonmissing) {
        return true;
      }
      // This loop ("while" instead of "if") permits duplicates in nums.
      while (current_missing == current_nonmissing) {
        if (nums != null) {
          @SuppressWarnings(
              "index") // This breaks the invariant, but it's checked right below and the function exits.
          /*@IndexFor("nums")*/ int current_index_temp = current_index + 1;
          current_index = current_index_temp;
          if (current_index >= nums.length) {
            if (add_ends) {
              current_missing++;
              return true;
            } else {
              return false;
            }
          }
          current_nonmissing = nums[current_index];
        } else if (nums_itor != null) {
          if (!nums_itor.hasNext()) {
            if (add_ends) {
              current_missing++;
              return true;
            } else {
              return false;
            }
          }
          // prev_nonmissing is for testing only
          long prev_nonmissing = current_nonmissing;
          current_nonmissing = nums_itor.next().longValue();
          if (!(prev_nonmissing < current_nonmissing)) {
            throw new Error(
                "Non-sorted Iterator supplied to MissingNumbersIteratorLong: prev_nonmissing = "
                    + prev_nonmissing
                    + ", current_nonmissing = "
                    + current_nonmissing);
          }
        } else {
          throw new Error("Can't happen");
        }
        current_missing++;
        return hasNext();
      }
      if (add_ends) {
        return (current_missing == current_nonmissing + 1);
      } else {
        throw new Error("Can't happen: " + current_missing + " " + current_nonmissing);
      }
    }

    @Override
    public Long next(/*>>>@GuardSatisfied MissingNumbersIteratorLong this*/) {
      if (!hasNext()) {
        throw new NoSuchElementException();
      }
      Long result = current_missing;
      current_missing++;
      return result;
    }

    @Override
    public void remove(/*>>>@GuardSatisfied MissingNumbersIteratorLong this*/) {
      throw new UnsupportedOperationException();
    }
  }

  /**
   * Return a tuple of (r,m) where no number in NUMS is equal to r (mod m) but all missing numbers
   * in their range are. Returns null if the input array has 0 length.
   *
   * @param nums the list of operands
   * @return a (remainder, modulus) pair that fails to match elements of nums
   */
  @SuppressWarnings({"purity", "lock"})
  /*@Pure*/
  /*@StaticallyExecutable*/
  public static long /*@Nullable*/ /*@ArrayLen(2)*/[] nonmodulus_strict(long[] nums) {
    // This implementation is particularly inefficient; find a better way to
    // compute this.  Perhaps obtain the new modulus numbers incrementally
    // instead of all at once.
    if (nums.length == 0) {
      return null;
    }
    long range = ArraysPlume.element_range(nums);
    if (range > 65536) {
      return null;
    }
    return nonmodulus_strict_long_internal(new MissingNumbersIteratorLong(nums, true));
  }

  private static long /*@Nullable*/ /*@ArrayLen(2)*/[] nonmodulus_strict_long_internal(
      Iterator<Long> missing) {
    // Must not use regular modulus:  that can produce errors, eg
    // nonmodulus_strict({1,2,3,5,6,7,9,11}) => {0,2}.  Thus, use
    // modulus_strict.
    CollectionsPlume.RemoveFirstAndLastIterator<Long> missing_nums =
        new CollectionsPlume.RemoveFirstAndLastIterator<Long>(missing);
    long[] result = modulus_strict_long(missing_nums, false);
    if (result == null) {
      return result;
    }
    if (!check_first_and_last_nonmodulus(result, missing_nums)) {
      return null;
    }

    return result;
  }

  /** The first argument is an array containing two elements. */
  private static boolean check_first_and_last_nonmodulus(
      long /*@ArrayLen(2)*/[] rm, CollectionsPlume.RemoveFirstAndLastIterator<Long> rfali) {
    long r = rm[0];
    long m = rm[1];
    long first = rfali.getFirst().longValue();
    long last = rfali.getLast().longValue();
    return ((r != mod_positive(first, m)) && (r != mod_positive(last, m)));
  }

  /**
   * Return a tuple of (r,m) where no number in NUMS is equal to r (mod m) but all missing numbers
   * in their range are.
   *
   * @param nums the list of operands
   * @return a (remainder, modulus) pair that fails to match elements of nums
   */
  public static long /*@Nullable*/ /*@ArrayLen(2)*/[] nonmodulus_strict_long(Iterator<Long> nums) {
    return nonmodulus_strict_long_internal(new MissingNumbersIteratorLong(nums, true));
  }

  // Old, slightly less efficient implementation that uses the version of
  // missing_numbers that returns an array instead of an Iterator.
  // /**
  //  * Return a tuple of (r,m) where no number in NUMS is equal to r (mod
  //  * m) but all missing numbers in their range are.
  //  */
  // public static long /*@Nullable*/ /*@ArrayLen(2)*/ [] nonmodulus_strict(long[] nums) {
  //   // This implementation is particularly inefficient; find a better way to
  //   // compute this.  Perhaps obtain the new modulus numbers incrementally
  //   // instead of all at once.
  //   if (nums.length == 0) {
  //     return null;
  //   }
  //   long range = ArraysPlume.element_range(nums);
  //   if (range > 65536) {
  //     return null;
  //   }
  //   return modulus(missing_numbers(nums));
  // }

  /**
   * Return a tuple of (r,m) where no number in NUMS is equal to r (mod m) but for every number in
   * NUMS, at least one is equal to every non-r remainder. The modulus is chosen as small as
   * possible, but no greater than half the range of the input numbers (else null is returned).
   *
   * @param nums the list of operands
   * @return a (remainder, modulus) pair that fails to match elements of nums
   */
  // This seems to give too many false positives (or maybe my probability
  // model was wrong); use nonmodulus_strict instead.
  @SuppressWarnings("purity")
  /*@Pure*/
  /*@StaticallyExecutable*/
  public static long /*@Nullable*/ /*@ArrayLen(2)*/[] nonmodulus_nonstrict(long[] nums) {
    if (nums.length < 4) {
      return null;
    }
    int max_modulus = ((int) (Math.min(nums.length / 2, ArraysPlume.element_range(nums) / 2)));

    // System.out.println("nums.length=" + nums.length + ", range=" + ArraysPlume.element_range(nums) + ", max_modulus=" + max_modulus);

    // no real sense checking 2, as common_modulus would have found it, but
    // include it to make this function stand on its own
    for (int m = 2; m <= max_modulus; m++) {
      // System.out.println("Trying m=" + m);
      boolean[] has_modulus = new boolean[m]; // initialized to false?
      int num_nonmodulus = m;
      for (int i = 0; i < nums.length; i++) {
        /*@IndexFor("has_modulus")*/ int rem = ((int) (mod_positive(nums[i], m)));
        if (!has_modulus[rem]) {
          has_modulus[rem] = true;
          num_nonmodulus--;
          // System.out.println("rem=" + rem + " for " + nums[i] + "; num_nonmodulus=" + num_nonmodulus);
          if (num_nonmodulus == 0) {
            // Quit as soon as we see every remainder instead of processing
            // each element of the input list.
            break;
          }
        }
      }
      // System.out.println("For m=" + m + ", num_nonmodulus=" + num_nonmodulus);
      if (num_nonmodulus == 1) {
        return new long[] {ArraysPlume.indexOf(has_modulus, false), m};
      }
    }
    return null;
  }
}
